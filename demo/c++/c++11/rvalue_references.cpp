/*
// =====================================================================================
// 
//       Filename:  rvalue_references.cpp
// 
//    Description:  右值引用介绍：T&&
//                  右值和左值的区别为：有命名或可取地址的值是左值，否则就是右值
//                  规则总结如下：
//                  1、左值与右值独立于他们的类型（与const无关），右值引用类型有可能是左值，也有可能是右值。
//                  2、auto&&或函数参数类型自动推到的T&&是一个未定的引用类型，被称为universal references，
//                     他可能是左值引用也有可能是右值引用类型，取决与初始化的值类型。
//                  3、所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用叠加都为左值引用。
//                     当T&&为模板参数时，输入左值，它会变为左值引用，输入右值则变为具名的右值引用。
//                  4、编译器会将已命名的右值引用视为左值，而将为命名的右值引用视为右值
//
//                  特别说明：
//                      C++11中，将右值细分为将亡值和纯右值。非引用返回的临时变量、运算表达式产生的临时变量、
//                      原始字面量和lambda表达式等都是纯右值。将亡值是C++11新增的、与右值引用相关的表达式，
//                      比如：将要被移动的对象，T&&函数返回值、std::move返回值和转换为T&&类型的转换函数的返回值
// 
//        Version:  1.0
//        Created:  05/27/2016 03:51:12 PM
//       Revision:  none
//       Compiler:  g++
// 
//         Author:  Elwin.Gao (elwin), elwin.gao4444@gmail.com
//        Company:  
// 
// =====================================================================================
*/

#include <cstdlib>
#include <iostream>

/* 
// ===  FUNCTION  ======================================================================
//         Name:  print_value
//  Description:   
// =====================================================================================
*/
static void print_value(int &i)
{
	std::cout << "lvalue: " << i << std::endl;
}		// -----  end of static function print_value  -----

/* 
// ===  FUNCTION  ======================================================================
//         Name:  print_value
//  Description:   
// =====================================================================================
*/
static void print_value(int &&i)
{
	std::cout << "rvalue: " << i << std::endl;
}		// -----  end of static function print_value  -----

/* 
// ===  FUNCTION  ======================================================================
//         Name:  print
//  Description:   
// =====================================================================================
*/
static void print(int &&i)
{
	print_value(i);
}		// -----  end of static function print  -----

/* 
// ===  FUNCTION  ======================================================================
//         Name:  print_forward
//  Description:  完美转发
// =====================================================================================
*/
static void print_forward(int &&i)
{
	// 完美转发多用于模板类或模板函数如果是确定的数据类型
	// 想在参数传递过程中，保留它的右值属性，使用std::move函数也是可以的，只是语义上有点怪异而已
	print_value(std::forward<int>(i));
	print_value(std::move(i));
}		// -----  end of static function print_forward  -----

/* 
// ===  FUNCTION  ======================================================================
//         Name:  main
//  Description:  
// =====================================================================================
*/
int main(int argc, char *argv[])
{
	int i = 42;	// i为左值，42为右值
	int &j = i;	// i为左值，j为左值引用
	// int &jerr = 42;	// 右值（立即数）无法作为左值引用
	const int &jconst = 42;	// const的左值引用为万能类型，可以引用右值
	int &&jr = 42;	// 右值引用可以直接引用右值
	// int &&jr_err = i;	// 右值引用是不可以直接引用左值的
	int &&jr_move = std::move(i);	// std::move可以将左值转为右值（而无任何其他行为）

	// 这个例子主要说明有命名的右值引用会被编译器认做左值
	print_value(i);
	print_value(42);
	print(42);

	// 完美转发就是为了解决上述问题而产生的，将数据按照原样的右值引用进行转发，而不会转换为左值
	print_value(i);
	print_value(42);
	print_forward(42);

	return EXIT_SUCCESS;
}				// ----------  end of function main  ----------

